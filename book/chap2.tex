\chapter{操作系统介绍}
\thispagestyle{empty}

如果你已经上过大学的操作系统课程，你就应该已经知道当计算机运行的时候程序的一些运作原理。如果没有的话，这本书（以及对应的课程）对于你而言可能会很难——所以你最好停止阅读本书，然后去最近的书店买一本相关背景的书学习之后再继续（Patt/Patel [PP03] 特别是 Bryant/O’Hallaron [BOH10] 都是很好的书）。

那么当一个程序在运行的时候发生了什么呢？

其实一个运行的程序只做了一个非常简单的事情：它执行了指令。每秒钟会有数百万条指令在执行（现在可能是数十亿条），处理器从内存中\textbf{取出}指令，\textbf{解码}（确定执行的行为），然后\textbf{执行}这条指令（它做一些设定好的工作，例如两个数字相加，访问内存，检查条件，跳转至一个函数等等）。在执行完这条指令之后，处理器开始执行下一条指令，一直如此，直到程序执行完成\footnote{当然，现代处理器在底层用了很多黑科技的技巧让程序运行的更快，例如：一次执行多条指令，然后按指令的输入顺序完成！但这不是我们这里所关心的。我们只关心大多数程序假设的简单模型：这些指令看起来以有序且连续的方式，一次执行一条指令}。

因此，我们只需描述基础的\textbf{冯.诺依曼}的计算机模型\footnote{冯.诺依曼是早期计算系统的先驱之一。他还做过关于博弈论和原子弹的开创性工作，并且在 NBA 打了6年的球。好吧，其中有一件事情是假的。}。听着很简单，对吧？但在这堂课中，我们需要学习当一个程序运行的时候，很多其他东西运行以达成系统\textbf{易于使用}这个主要目标。

这是一整套软件体系，实际上，这是让其可靠的更易于运行多个程序（即使是表面上让你感觉是同时运行的），运行程序共享内存，根据设备动态调整程序，或者类似于这些的有趣的东西。这个整套的软件体系被称为\textbf{操作系统(OS)}\footnote{早期操作系统也被称之为\textbf{监督者}或\textbf{管理控制程序}。显然后者听起来太热情了（可以看电影『创·战纪』了解详情），幸亏操作系统流行起来并且取代了后者}，它是来保证整个系统操作正确且有效又易于使用的方式。

\begin{tcolorbox}[colframe=grey,colback= grey,arc=0pt,left=6pt,right=6pt,top=6pt,bottom=6pt,boxsep=0pt]
\begin{center}
  问题的关键\\
  如何虚拟化资源
\end{center}
我们会在书中简洁明快的回答这个中心问题：操作系统如何虚拟化资源？这是我们问题的核心。为什么这是操作系统的主要问题，答案显而易见：虚拟化让系统更易于使用，那么，让我们专注于怎么做：操作系统以什么机制和策略来实现虚拟化？操作系统如何高效实现这个功能？哪些硬件功能是需要支持的？

我们将使用『核心问题』，像这样一个黑盒子，来整理我们在构建一个操作系统时遇到的所有问题。因此在这个特殊主题的笔记里，你会发现一个或更多的重量级难题（当然, 是适当数量）。当然，在这一章的详情中，有这些难题的解决方案，或者至少有基本的解决思路。
\end{tcolorbox}

操作系统实现这些需求的主要方法是被我们称之为\textbf{虚拟化}的技术。简而言之，操作系统调用\textbf{硬件}资源（例如处理器，内存或硬盘）然后将其转化为更通用，强大且易于使用的\textbf{虚拟}形式。因此，我们有时候将操作系统引申为\textbf{虚拟机}。

当然，为了让用户能够告诉操作系统做什么以及使用虚拟机的特性（例如运行程序，分配内存或访问文件），操作系统也支持一些API接口给用户调用。事实上，一个典型的操作系统会给出数百个\textbf{系统调用}以供应用程序使用。因为系统支持这些调用来运行程序，访问内存、设备，以及其他的操作。我们也将这些称之为系统给程序提供的\textbf{标准库}。

最后，因为虚拟化允许多个程序同时运行（即共享CPU），同时访问他们自己的结构和数据（即共享内存），以及同时访问设备（即共享磁盘等等），所以操作系统有时被认为是\textbf{资源管理器}。每个CPU，内存和磁盘都是系统的\textbf{资源}；因此，操作系统的\textbf{角色}就是管理这些资源，有效或者公平或者考虑到其他可能的目标的实现。为了更好的理解操作系统的角色，让我们看一些例子。

\newpage

\begin{figure}[ht]
\begin{lstlisting}  
#include <stdio.h> 
#include <stdlib.h> 
#include <sys/time.h> 
#include <assert.h> 
#include "common.h"
int
main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: cpu <string>\n");
        exit(1);
    }
    char *str = argv[1];
    while (1) {
        Spin(1);
        printf("%s\n", str);
    }
    return 0;
}
\end{lstlisting}
\caption{\textbf{简单示例：有关循环及打印的代码}}
\end{figure}

\section{虚拟化CPU}
    
图2.1描述了我们的第一段程序。它并没有做什么。实际上这段程序做的只是调用 Spin() 这个函数，一旦运行了一秒钟，就重复检查时间并返回。然后打印出用户在命令行上传入的字符串，并且一直重复。

我们将文件保存为 cpu.c 并且编译然后通过一个单独处理器在系统上运行（或者有时候我们称之为 \textbf{CPU}）。接下来我们会看到以下效果。

\begin{verbatim}
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
ˆC
prompt>
\end{verbatim}

不是太有趣的运行——系统开始运行程序，循环检查时间直到经过一秒。一旦经过一秒，代码打印出用户输入的字符（在这个例子中，就是字母 A），然后继续。注意程序会一直运行下去；只有按下“Control-C”（在基于 UNIX 的系统上就会终止前台运行的程序）才能中断程序。

现在让我们做相同的事情，但这次我们运行这个程序的多个不同的实例。图2.2显示了这个稍微复杂例子的结果。

\begin{figure}[ht]
\begin{verbatim}
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
\end{verbatim}
\caption{\textbf{同时运行多个程序}}
\end{figure}

好了，现在事情变得更有趣了。尽管我们只有一个处理器，但我们的四个程序却同时运行了！这样的魔法是怎么发生的呢？\footnote{注意我们是怎么同时运行四个程序的，通过 \& 符号。这样做会在 tcsh shell 的后台运行一份作业。}